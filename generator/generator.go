package main

import (
	"bytes"
	"fmt"
	"github.com/dave/jennifer/jen"
	"reflect"
	"runtime"
	"strings"
	"text/template"
)

const (
	processorId     = "processor"
	processorTypeId = "RedisProcessor"
	redisId         = "redis"
	cmdId           = "cmd"
	ctxImportId     = "context"
	ctxId           = "ctx"
)

func generateHeader(pkg GoredisPackage, root *jen.File) {
	root.HeaderComment("Code generated by rejonson. DO NOT EDIT.")

	root.ImportName(pkg.GoRedisImport, redisId)
	if pkg.HasContext {
		root.ImportName(ctxImportId, ctxImportId)
	}
}

func generateFunctional(cmd RejsonCommand, pkg GoredisPackage, root *jen.File) {

	var fnBody []jen.Code

	v := reflect.ValueOf(cmd.CommandCtr)
	if v.Kind() != reflect.Func {
		panic(fmt.Errorf("CommandCtr has to be func and not %s", v.Kind().String()))
	}
	fullPaths := strings.Split(runtime.FuncForPC(v.Pointer()).Name(), ".")
	ids, decl := getFunctionParamIds(cmd, pkg.HasContext, false, true)

	fnBody = append(fnBody, decl)

	fnBody = append(fnBody, jen.Id(cmdId).Op(":=").Qual(pkg.GoRedisImport, fullPaths[len(fullPaths)-1]).
		Call(ids...))

	fnBody = append(fnBody, jen.Comment("ignore returned error, it is part of the cmd"))

	var processArgs []jen.Code
	if pkg.HasContext {
		processArgs = append(processArgs, jen.Id(ctxId))
	}
	processArgs = append(processArgs, jen.Id(cmdId))
	fnBody = append(fnBody, jen.Id("_").Op("=").Id(processorId).Dot("Process").Call(processArgs...))

	fnBody = append(fnBody, jen.Return(jen.Id(cmdId)))

	root.Func().Id(cmd.Name).Params(createFunctionalParams(cmd, pkg.HasContext, true)...).
		Id(v.Type().Out(0).String()).
		Block(fnBody...)
}

func generateMethod(cmd RejsonCommand, pkg GoredisPackage, root *jen.File) {

	for _, caller := range []string{"Client", "Pipeline"} {
		v := reflect.ValueOf(cmd.CommandCtr)
		if v.Kind() != reflect.Func {
			panic(fmt.Errorf("CommandCtr has to be func and not %s", v.Kind().String()))
		}

		ids, _ := getFunctionParamIds(cmd, pkg.HasContext, true, false)

		root.Func().Params(jen.Id(processorId).Op("*").Id(caller)).Id(cmd.Name).Params(createFunctionalParams(cmd, pkg.HasContext, false)...).
			Id(v.Type().Out(0).String()).
			Block(
				jen.Return().Id(cmd.Name).Call(ids...))
	}
}

func createFunctionalParams(cmd RejsonCommand, hasContext bool, includeProcessor bool) (params []jen.Code) {
	if includeProcessor {
		params = append(params, jen.Id(processorId).Id(processorTypeId))
	}

	if hasContext {
		params = append(params, jen.Id(ctxId).Qual(ctxImportId, "Context"))
	}

	params = append(params, createCmdSpecificParams(cmd)...)
	return
}

func cmdParamsLen(cmd RejsonCommand) jen.Code {
	paramsLen := jen.Lit(len(cmd.Args) + 1)
	if cmd.HasVariadic() {
		paramsLen = paramsLen.Op("-").Lit(1)
		paramsLen.Op("+").Len(jen.Id(cmd.Last().Name))
	}
	return paramsLen
}

func generateToInterfaceSlice(cmd RejsonCommand) (decl *jen.Statement, arrId *jen.Statement) {

	arrId = jen.Id("paramsToItf")
	scope := []jen.Code{
		arrId.Clone().Op(":=").Id("make").Call(jen.Index().Interface(), jen.Lit(0), cmdParamsLen(cmd)).Op(";"),
	}
	scope = append(scope, arrId.Clone().Op("=").Append(arrId.Clone(), jen.Lit(cmd.Cmd)).Op(";"))
	for _, arg := range cmd.Args {
		id := jen.Id(arg.Name)
		if arg.IsVariadic {
			id.Op("...")
		}
		scope = append(scope, arrId.Clone().Op("=").Append(arrId.Clone(), id).Op(";"))
	}

	return jen.Add(scope...), arrId
}

func getFunctionParamIds(cmd RejsonCommand, hasContext bool, includeProcessor bool, toInterfaceSlice bool) (ids []jen.Code, decl *jen.Statement) {
	decl = jen.Empty()
	if includeProcessor {
		ids = append(ids, jen.Id(processorId))
	}

	if hasContext {
		ids = append(ids, jen.Id(ctxId))
	}

	if toInterfaceSlice {
		d, arrId := generateToInterfaceSlice(cmd)
		decl = d
		ids = append(ids, arrId.Clone().Op("..."))
		return
	}
	for _, param := range cmd.Args {
		id := jen.Id(param.Name)

		if param.IsVariadic {
			id = id.Op("...")
		}
		ids = append(ids, id)
	}

	return
}

func createCmdSpecificParams(cmd RejsonCommand) (res []jen.Code) {
	for _, param := range cmd.Args {
		paramType := param.Type.String()
		if param.Type == reflect.Interface {
			paramType += "{}"
		}
		if param.IsVariadic {
			res = append(res, jen.Id(param.Name).Op("...").Id(paramType))
		} else {
			res = append(res, jen.Id(param.Name).Id(paramType))
		}
	}
	return
}

func Generate(pkg GoredisPackage, cmds []RejsonCommand) {

	templates := template.Must(template.New("root").Funcs(template.FuncMap{
		"hasContext": func() bool {
			return pkg.HasContext
		},
	}).ParseGlob("./*.go.tmpl"))
	root := jen.NewFile("rejonson")
	generateHeader(pkg, root)

	for _, cmd := range cmds {
		root.Comment(fmt.Sprintf("---- %s ----", cmd.Name))
		generateFunctional(cmd, pkg, root)
		generateMethod(cmd, pkg, root)
	}

	withFile("../"+pkg.Output, func(b *bytes.Buffer) {
		must(root.Render(b))
		must(templates.ExecuteTemplate(b, "client_defs.go.tmpl", pkg))
	})

	withFile("../"+pkg.TestFile(), func(b *bytes.Buffer) {
		must(templates.ExecuteTemplate(b, "rejonson_test.go.tmpl", pkg))
	})
}
